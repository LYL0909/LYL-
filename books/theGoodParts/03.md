[The Good Parts](https://item.jd.com/11090963.html)
# 对象 Objects

- 简单数据类型

  数字、字符串、布尔值、null、undefined

  1. 数字类型不区分整型和浮点型，只有一个类型Number   
  JS不适合高精度运算（0.1+0.2=0.30000000000000004）

  2. 字符串
    
    str.substring(start,end)
- 复杂数据类型
  object 类型 { }、[ ]、()=>{} object array function reg

  Object JS 一切皆对象(除了简单数据类型其他都是对象，数组、函数、正则表达式均为对象，例如：array.length)

- typeof运算符，可得到变量类型
- JS数据类型分为简单数据类型和复杂数据类型，使用typeof 关键字可得到变量的数据类型。但是，null、 浮点数、array在意料之外也显示为object，因为JS有 The Bad Parts（有问题的）

- JS是一本什么语言？
  脚本语言、全栈语言（运行在命令行）、动态弱类型语言

## 对象字面量
- 花括号内的 0~多个名值对 对象字面量 逗号分隔开

- 属性命名 合法化 不能为保留字 加引号解决 空字符串也能成为一个属性

- 声明：```var empty_object = {}; ```

- 对象可嵌套

## 检索
- 获取对象中包含的值
- 语法：
  1.  ``` object["属性名"] ```
  2.  ``` object.属性```
- 检索不存在的成员 返回undefined
- 优先级 .表示法 > [ ]表示法
- ||运算符
- 检索undefined值  TypeError  使用&&运算符避免报错

## 更新
- 更新对象中的值 

- 语法：
  1. ```object["属性名"] = value //属性名已存在修改 值，不存在 在对象中添加 新的名值对 ```
  2. ```object.属性名 = value ```

- 优先级 .表示法 > [ ]表示法

- 更新 可嵌套对象

## 引用
- 对象通过引用来传递

- 对象本身不会被复制 而是对象的地址被复制

- 通过引用修改对象的属性值，对象本身的属性值也会改变

## 原型
- 每个对象都有对象原型 可从对象原型中继承属性
- 通过对象字面量创建的对象 连接到Object.prototype标准对象
- 对对象进行更新时，对象原型不会更新

## 反射
- 确定对象 对象属性 变量的类型
- 语法：` typeof ...`
- typeof 有缺陷 数组、函数、正则表达式 都判断为object

## 枚举
- for in 遍历对象中所有属性名
- 使用typeof 排除函数 `typeof Object[name] !== 'function' `
- 缺点：属性名出现顺序不定 不推荐使用 
- 创建数组以正确顺序包含属性名 使用for得到想要的属性 避免发掘出原型链中的属性 且按照我们想要的顺序取得属性

## 删除
- 删除对象属性
- 语法： ` delete Object.属性`
- 删除对象的属性可能会让来自原型链中的属性浮现出来

## 减少全局变量污染
- JS 随意定义全局变量 但削弱了程序灵活性
- 最小化使用全局变量 只创建一个 var
- 把多个全局变量整理在一个名称空间下 降低与其他程序的相互影响 增强代码可读性
